\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Toros Margaryan Comp 490 Senior Paper}
\author{Toros Margaryan}
\date{October 2021}

\begin{document}

\maketitle

\section{Introduction}
    Magic squares are discrete mathematical structures that don't have many (if any) applications to applicable real world mathematical problems and are primarily studied due to a piqued interest of the structure. As such, some of those who study magic squares like to study all magic squares to see what (if any) patterns arise for the various sizes of magic squares. As of the writing of this paper, all magic squares of size 3 and 4 have been discovered and documented, and while some magic squares of greater sizes have been found, there is no source that lays all magic squares of an arbitrary size $n$ greater than 4. This leads to the attempted implementation of an algorithm that can determine and find all of the magic squares of an arbitrary size n. Currently, the most elementary brute force method for finding all magic squares of an arbitrary size n has a worst-case time complexity of $O(n^2!)$. In this paper, we will explore some of the properties of magic squares and attempt to come up with an algorithm that can achieve the same goal with a more "efficient" worst-case time complexity.     
\section{Background}
    A magic square is an $n$ by $n$ matrix whose elements are compromised of the integers 1 through $n^{2}$ (note that none of the integers can repeat) oriented in such a manner that  
    the sum of the rows, columns, and the diagonal's of said matrix all sum to the same special value (which will be referred to as the magic
    sum). The magic sum for a given magic square of size n is equivalent to: $(n)(n^2 + 1)/2$.
    
    To understand the worst case time complexity of the elementary brute force method, I will attempt to explain the process of the elementary brute force method. Essentially, given there are $n^2$ many integers and $n^2$ many matrix position to fill, we attempt to construct all possible magic squares by first filling the top left corner of the magic square with one of the $n^2$ integers. Note that we can do this $n^2$ many times for each of the $n^2$ digits. We then move over to the next matrix position (on the right of the top left corner) and select one of the $n^2 - 1$ remaining integers. Note once more that we can do this with all of the remaining integers. Following this process inductively until there are no more remaining integers, all that is left to do is to check which of these constructed squares qualifies the conditions necessary to be a magic square and to return all the matrices that qualify as magic squares. Thus we have that there are $n^2$ many ways to perform the first step, $n^2 - 1$ ways to perform the second step, $n^2 - 2$ ways of performing the third step, and so on until there is only $1$ way to perform the last step. Since these insertions are happening simultaneously (ie: none of the integer may repeat) we have that there are $(n^2) * (n^2 - 1) * \cdots * (2) * (1) = n^2!$ many different ways of placing the integers $1\cdots n^2$ inside an $n$ by $n$ matrix. Thus by searching through all these outputs, we achieve a worst-case time complexity of $O(n^2!)$.
    
\section{Literature Review}
    There is 1 unique magic square size 3 and 880 magic squares size 4, 275 million 5 by 5 etc... %still working on it
\section{Evaluation Metrics}
    While it is true that defining how much more efficient an algorithm is from the elementary brute force method is relatively simple given the time complexity of the more efficient algorithm, determining weather or not an algorithm is actually "efficient" is more of an subjective ordeal. As such, I will define an algorithm as "efficient" if it makes a relatively significant reduction in time complexity compared to the worst-case time complexity of the elementary brute force method for smaller sizes of n. A relatively significant reduction in worst-case time complexity will be defined as achieving a time complexity close to the most efficient elementary algorithm that would solve this problem. Since the most efficient algorithm is unknown for this problem, I will analyze how much savings have been achieved by the "efficient" algorithm as compared to the elementary brute force method.    

\end{document}
